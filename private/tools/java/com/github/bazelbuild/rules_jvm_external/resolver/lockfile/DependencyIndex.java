// Copyright 2024 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.github.bazelbuild.rules_jvm_external.resolver.lockfile;

import com.github.bazelbuild.rules_jvm_external.Coordinates;
import com.github.bazelbuild.rules_jvm_external.resolver.DependencyInfo;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * Renders a dependency index containing class-level information for each artifact. This is stored
 * separately from the lock file since class information can be large and is not needed for
 * resolution.
 *
 * <p>Classes are grouped by package to reduce file size. For example:
 *
 * <pre>
 * {
 *   "version": 1,
 *   "classes": {
 *     "com.google.guava:guava": {
 *       "com.google.common.base": ["Optional", "Preconditions"],
 *       "com.google.common.collect": ["ImmutableList", "ImmutableMap"]
 *     }
 *   }
 * }
 * </pre>
 */
public class DependencyIndex {

  private static final int VERSION = 1;

  private final Set<DependencyInfo> infos;

  public DependencyIndex(Set<DependencyInfo> infos) {
    this.infos = infos;
  }

  public Map<String, Object> render() {
    // Map from artifact key -> (package -> set of simple class names)
    Map<String, Map<String, Set<String>>> classes = new TreeMap<>();

    infos.forEach(
        info -> {
          // Skip sources and javadoc artifacts - they don't have classes
          String classifier = info.getCoordinates().getClassifier();
          if ("sources".equals(classifier) || "javadoc".equals(classifier)) {
            return;
          }

          Set<String> infoClasses = info.getClasses();
          if (infoClasses == null || infoClasses.isEmpty()) {
            return;
          }

          String artifactKey = asKey(info.getCoordinates());
          Map<String, Set<String>> packageToClasses = new TreeMap<>();

          for (String fqcn : infoClasses) {
            String packageName = extractPackage(fqcn);
            String simpleClassName = extractSimpleClassName(fqcn);

            packageToClasses
                .computeIfAbsent(packageName, k -> new TreeSet<>())
                .add(simpleClassName);
          }

          classes.put(artifactKey, packageToClasses);
        });

    Map<String, Object> index = new TreeMap<>();
    index.put(
        "__AUTOGENERATED_FILE_DO_NOT_MODIFY_THIS_FILE_MANUALLY", "THERE_IS_NO_DATA_ONLY_ZUUL");
    index.put("version", VERSION);
    index.put("classes", classes);

    return index;
  }

  private static String asKey(Coordinates coords) {
    return coords.asKey().toString();
  }

  private static String extractPackage(String fqcn) {
    int lastDot = fqcn.lastIndexOf('.');
    if (lastDot == -1) {
      return "";
    }
    return fqcn.substring(0, lastDot);
  }

  private static String extractSimpleClassName(String fqcn) {
    int lastDot = fqcn.lastIndexOf('.');
    if (lastDot == -1) {
      return fqcn;
    }
    return fqcn.substring(lastDot + 1);
  }
}
