common --enable_runfiles

build --java_language_version=11
build --java_runtime_version=remotejdk_11

build --tool_java_language_version=11
build --tool_java_runtime_version=remotejdk_11

build --experimental_strict_java_deps=strict
build --explicit_java_test_deps

# Make sure we get something helpful when tests fail
test --verbose_failures
test --test_output=errors

# Required to get `protobuf` compiling. Note that MSVC requires a
# different flag than both macOS and Linux.

common --enable_platform_specific_config
common:linux --cxxopt=-std=c++17
common:linux --host_cxxopt=-std=c++17
common:macos --cxxopt=-std=c++17
common:macos --host_cxxopt=-std=c++17
common:windows --cxxopt=/std:c++17
common:windows --host_cxxopt=/std:c++17

# Enable protobuf MSVC support on Windows
build:windows --define=protobuf_allow_msvc=true

# rules_kotlin 2.x has a bug where the Kotlin compiler worker fails to
# resolve runfiles on Windows without this flag.
# https://github.com/bazelbuild/rules_kotlin/issues/1309
build:windows --legacy_external_runfiles

# Every JVM creates a temporary performance instrumentation file in
# /tmp/hsperfdata_$USERNAME/$PID. When we use sandboxing, we use PID
# namespaces, which means that the PIDs are virtualized and all
# running JVMs believe they are PID 2.
#
# This means that they all open/ftruncate/mmap the same file and that
# gives you SIGBUS eventually, because "It tries to read an address
# that no longer exists from an mmap'd file".
#
# https://github.com/bazelbuild/bazel/issues/3236#issuecomment-310776024

build --sandbox_tmpfs_path=/tmp

common --incompatible_enable_proto_toolchain_resolution
common --@protobuf//bazel/toolchains:prefer_prebuilt_protoc=true

# Allows the examples to extend the default bazelrc
try-import %workspace%/.bazelrc.example
